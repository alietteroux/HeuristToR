[{"path":"https://alietteroux.github.io/HeuristToR/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Aliette Roux. Author, maintainer.","code":""},{"path":"https://alietteroux.github.io/HeuristToR/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Roux (2023). HeuristToR: make easier quantitative analysis Heurist databases. https://github.com/alietteroux/HeuristToR, https://alietteroux.github.io/HeuristToR/.","code":"@Manual{,   title = {HeuristToR: To make easier quantitative analysis from Heurist databases},   author = {Aliette Roux},   year = {2023},   note = {https://github.com/alietteroux/HeuristToR, https://alietteroux.github.io/HeuristToR/}, }"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"heuristtor","dir":"","previous_headings":"","what":"To make easier quantitative analysis from Heurist databases","title":"To make easier quantitative analysis from Heurist databases","text":"HeuristToR aims make easier quantitative analysis Heurist databases.","code":""},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"To make easier quantitative analysis from Heurist databases","text":"can install development version HeuristToR GitHub :  ","code":"# install.packages(\"devtools\") devtools::install_github(\"alietteroux/HeuristToR\")"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"before-using-heuristtor--export-xml-files-from-heurist","dir":"","previous_headings":"","what":"Before using HeuristToR : export XML files from Heurist","title":"To make easier quantitative analysis from Heurist databases","text":"hr_import() reads XML files exported Heurist. use , two XML files must first exported Heurist : XML file including data (fields’values entered database) : XML file can exported Heurist via Explore menu > Export > XML. careful : records selected Heurist session export, data theses selected records may exported. XML file exported Heurist describing database structure (vocabularies, fields’caracteristics…) : XML file can exported Heurist via Design menu > Download > Structure (XML). open window looking like : , please wait seconds try another web browser. , click right mouse button save XML.   ","code":""},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"example-database-and-data-files","dir":"","previous_headings":"","what":"Example database and data files","title":"To make easier quantitative analysis from Heurist databases","text":"’ve created fictitious Heurist database, named “aliet_test_R”, viewable https://heurist.huma-num.fr/heurist/?db=aliet_test_R&website database, ’ve exported two XML files : look folder “documents/data_example” Github repository, directly download files .  ","code":""},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"read-data-and-paradata-from-heurist-database-with-hr_import-function","dir":"","previous_headings":"","what":"Read data and paradata from Heurist database, with hr_import() function","title":"To make easier quantitative analysis from Heurist databases","text":"function returns several dataframes Environment : Heurist ‘record type’ dataframe : dataframes, row matches Heurist ‘record’ dataframe named “z.h.tables.fields” : row describes field used Heurist ‘record type’ (type, help text, requirement, repeatability…) dataframe named “z.h.vocabularies” : row matches term used Heurist vocabulary ; term joined level (ranking position vocabulary) attached parents’terms hr_import() returns error messages ’ll try , please contact us. example Heurist database (named “aliet_test_R”), ’ve obtained 8 dataframes :  hr_import() taken long time, remember can save objects environment folder, open afterwards (see , last part page). ’re interested function code : hr_import() reads XML files , actually, function script uses readLines() read . Indeed, seems R slow parse XML files, yet XML Heurist files can big ! Therefore, code may seem convoluted, using regular expressions different functions recover XML structure. Note previously, proposed solution using xml2 library, retrievable folder “documents” Github repository, file “archive_import_Heurist_dans_R_via_XML”. give slow… Thereafter, ’ll manage data using tidyr ggplot2 ; ’ll display tables knitr::kable().  ","code":"library(HeuristToR)  hr_import(data.file=\"documents/data_example/aliet_test_R_data.xml\",           structure.file=\"documents/data_example/aliet_test_R_structure.xml\") #> We're importing data and structure files (most time-consuming step)... Thank you for waiting... #> Data and structure files have been successfully imported. Now we're selecting and managing data... Thank you for waiting... #> We've finished. It's ready to use ! #> Import has required 7.36 secs library(tidyverse) library(knitr)"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"about-columns-names-and-formats","dir":"","previous_headings":"","what":"About columns names and formats","title":"To make easier quantitative analysis from Heurist databases","text":"Let’s look dataframe Personne (6 rows 24 columns) : Rows ordered according column starting “z.h.id.”. numbers match records IDs automatically created Heurist ; depend date added. look column names formats : Note : dataframe contains “paradata” fields : fields starting “z.h.”. column starting “z.h.title” corresponds “Heurist title masks”. Colnames “display fields names” Heurist forms (database fields names). Therefore, columns may name : ’s possible contributor renamed existing field name already present database (like “Nom” example). cases, hr_import() automatically adds position number names (see Nom_1 Nom_2 example). Temporal, spatial file fields declined several columns : see , part “Dealing temporal, spatial file fields”. columns character, except : paradata fields (z.h.visibility, z.h.visnote, z.h.workgroup, z.h.workgroup.id) : factor fields type “enum” “relationtype” (see column field.type dataframe z.h.tables.fields) “repeatable” (see column field.MaxValues dataframe z.h.tables.fields) : factor (like Sexe example) fields ending “.temporal.type”, describing records values spatial fields : factor fields type “float” (see column field.type dataframe z.h.tables.fields) “repeatable” (see column field.MaxValues dataframe z.h.tables.fields) : numeric (like Nombre de publications example). , ’re abble know levels “enum” fields ; perform arithmetic “float” fields :  ","code":"Personne %>% kable() data.frame(colname=names(Personne),            format=as.character(sapply(Personne, class))) %>%   kable() levels(Personne$Sexe) #> [1] \"Female\" \"Male\" summary(Personne$`Nombre de publications`) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    8.00   15.25   17.50   17.67   19.75   28.00"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"dealing-with-repeatable-fields-multiple-values-in-a-field-for-one-record","dir":"","previous_headings":"","what":"Dealing with “repeatable” fields (multiple values in a field for one record)","title":"To make easier quantitative analysis from Heurist databases","text":"“Repetable” fields match value equal 1 column field.MaxValues dataframe z.h.tables.fields. Let’s look “repeatable” fields tables Laboratoire,Objet Personne : column Discipline(s) table Laboratoire appears “repeatable” field, look records : Usign hr_import(), different values “repeatable” field one record separated ” // “. can count records two different ways : looking combinations terms (see option ) ; looking terms (see option B ) : case, use separate_rows() function tidyr. also use separate_rows() ’d like know objects discovered different researchers (table Personne.Objet). , ’re abble count discovered objects per researcher.  ","code":"z.h.tables.fields %>%   filter(table.name %in% c(\"Laboratoire\",\"Objet\",\"Personne\") &            field.MaxValues!=1) %>%   select(table.name,field.DisplayName,field.type) %>%   kable() Laboratoire %>%    select(z.h.title.Laboratoire,`Discipline(s)`) %>%   kable() # Option A Laboratoire %>%    count(`Discipline(s)`) %>%   kable() # Option B Laboratoire %>%    separate_rows(`Discipline(s)`,sep= \" // \") %>%   count(`Discipline(s)`) %>%   kable() Objet %>% select(z.h.id.Objet,`Découvreur(s)`) %>%   kable() Personne.Objet <- Personne %>%    select(z.h.id.Personne,z.h.title.Personne) %>%   left_join(Objet %>%               select(z.h.id.Objet,`Découvreur(s)`) %>%               separate_rows(`Découvreur(s)`,sep=\" // \"),             by=c(\"z.h.id.Personne\"=\"Découvreur(s)\")) Personne.Objet %>% kable() Personne.Objet %>%    group_by(z.h.title.Personne) %>%   summarise(nb.objets=sum(!is.na(z.h.id.Objet))) %>%   arrange(desc(nb.objets)) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"columns-zhreversepointer","dir":"","previous_headings":"","what":"Columns “z.h.reversePointer”","title":"To make easier quantitative analysis from Heurist databases","text":"Since 2023, z.h.reversePointer columns “target dataframes”. columns report IDs related entities. two types “target dataframes” : “target dataframes” corresponding resource fields ; “target dataframes” corresponding children records.","code":""},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"target-dataframes-corresponding-to-resource-fields","dir":"","previous_headings":"Columns “z.h.reversePointer”","what":"“Target dataframes” corresponding to resource fields","title":"To make easier quantitative analysis from Heurist databases","text":"example, 7 Heurist’fields type resource : Heurist’environment, type ‘Record pointer’. example : field Lieu de la trouvaille (table Objet) → table Place (target) field Découvreur(s) (table Objet) → table Personne (target) (example), dataframe Personne contains z.h.reversePointer listing discovered objects. Lou Ragan discovered two objects : ID-61 ID-73 ; et l’objet ID-69 été découvert par Sandra Lacouverture et Edgar Letracteur (see ).","code":"z.h.tables.fields %>%    filter(field.type==\"resource\") %>%   select(table.name,field.DisplayName,field.type) %>%   kable() Personne %>%    select(z.h.id.Personne,z.h.title.Personne,z.h.reversePointer) %>%   kable() Objet %>% select(z.h.id.Objet,z.h.title.Objet,`Découvreur(s)`) %>% kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"target-dataframes-corresponding-to-children-records","dir":"","previous_headings":"Columns “z.h.reversePointer”","what":"“Target dataframes” corresponding to children records","title":"To make easier quantitative analysis from Heurist databases","text":"type information hasn’t well traced yet HeuristToR package : ’s easy recover “children” fields ! example, dataframe “Objet - Exposition” gathers “children” field Expositions (table Objet). Therefore, dataframe “Objet - Exposition” contains z.h.reversePointer listing “parents”’objects. column z.h.reversePointer “child” dataframe necessarily “repeatable”.  ","code":"Objet %>% select(z.h.id.Objet,Expositions) %>% kable() `Objet - Exposition` %>% select(`z.h.id.Objet - Exposition`,z.h.reversePointer) %>% kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"gathering-terms-in-a-vocabulary","dir":"","previous_headings":"","what":"Gathering terms in a vocabulary","title":"To make easier quantitative analysis from Heurist databases","text":"“Terms list” fields match value “enum” column field.type dataframe z.h.tables.fields. look informed fields (empty fields), select fields matching value “empty” column field.empty z.h.tables.fields. column Type d’objet table Objet appears “terms list” field, count records per term : Actually, terms nested. look vocabulary structure (“tree”), select rows z.h.vocabularies field.JsonTermIDTree one field “Type d’objet” described z.h.tables.fields. see vocabulary named “Type d’objets vocab” (see column Level1) composed 4 levels (see column maxLevel). following lines, gather terms “Level3”, “Level2”.  ","code":"z.h.tables.fields %>%   filter(field.type==\"enum\" & field.empty==\"no empty\") %>%   select(table.name,field.DisplayName,field.type) %>%   kable() Objet %>% count(`Type d'objet`) %>% kable() voc <- z.h.vocabularies %>%    semi_join(z.h.tables.fields %>%                filter(field.DisplayName==\"Type d'objet\"),             by=\"field.JsonTermIDTree\")  voc %>% kable() # Gathering to \"Level 3\" Objet %>% count(`Type d'objet`) %>%   left_join(voc,by=c(\"Type d'objet\"=\"trm_Label\")) %>%   group_by(Level3) %>% summarise(nb=sum(n)) %>%   kable() # Gathering to \"Level 2\" Objet %>% count(`Type d'objet`) %>%   left_join(voc,by=c(\"Type d'objet\"=\"trm_Label\")) %>%   group_by(Level2) %>% summarise(nb=sum(n)) %>%   kable()"},{"path":[]},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"relationship-marker-fields","dir":"","previous_headings":"Dealing with “Record relationship”","what":"“Relationship marker” fields","title":"To make easier quantitative analysis from Heurist databases","text":"“Relationship marker” fields match value “relmarker” column field.type dataframe z.h.tables.fields. Let’s look “relation markers” used database : see contributor created 2 “relationship marker” fields “Personne” : usage recommended may create problems viewing records Heurist. ’s recommended, exist ! XML data file, values “relationship marker” fields informed “relationship” : can recover table belongs , can’t recover field belongs (2 “relationship marker” fields created “record type”). Therefore, hr_import() function automatically creates one unique “relationship marker” field table : field match column finishing “.relationship”. Let’s look dataframe Personne :","code":"z.h.tables.fields %>%   filter(field.type==\"relmarker\") %>%   select(table.name,field.DisplayName,field.type) %>%   kable() names(Personne) #>  [1] \"z.h.id.Personne\"                   \"z.h.title.Personne\"                #>  [3] \"Nom_1\"                             \"Prénom\"                            #>  [5] \"Sexe\"                              \"Date de naissance.temporal.raw\"    #>  [7] \"Date de naissance.temporal.type\"   \"Date de naissance.DAT.raw\"         #>  [9] \"Date de naissance.DAT.year\"        \"Date de naissance.DAT.month\"       #> [11] \"Date de naissance.DAT.day\"         \"Date de naissance.property.COM\"    #> [13] \"Date de naissance.property.DET\"    \"Lieu de naissance.geo.type\"        #> [15] \"Lieu de naissance.geo.wkt\"         \"Nombre de publications\"            #> [17] \"Nom_2\"                             \"Carrière & Parentèle.relationship\" #> [19] \"z.h.added\"                         \"z.h.citeAs\"                        #> [21] \"z.h.modified\"                      \"z.h.reversePointer\"                #> [23] \"z.h.workgroup\"                     \"z.h.visibility\"                    #> [25] \"z.h.visnote\"                       \"z.h.workgroup.id\""},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"relation-vocabularies","dir":"","previous_headings":"Dealing with “Record relationship”","what":"“Relation” vocabularies","title":"To make easier quantitative analysis from Heurist databases","text":"“Relationship marker” fields necessarily use vocabulary. vocabularies match value “relation” column trm_Domain dataframe z.h.vocabularies. Let’s look different vocabularies (Level1) used “relationship marker” fields : relationships Family","code":"z.h.vocabularies %>%    filter(trm_Domain==\"relation\") %>%   distinct(Level1) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"record-relationship-dataframe","dir":"","previous_headings":"Dealing with “Record relationship”","what":"“Record relationship” dataframe","title":"To make easier quantitative analysis from Heurist databases","text":"contributor informs “relationship” via “relationship marker” Heurist, inverse relation automatically created Heurist reports. XML data file, seems can recover recorded relations inverses (January 2023 ; haven’t time ckeck November 2023). hr_import() duplicates relationship original table : relationship B, hr_import() automatically creates relationship B . “Original” relationships “created” inverses can distinguished column z.h.original dataframe Record relationship. , want uniquely treat “original” relationships, can filter records column. Let’s look relationship records regarding family links (Level1==“4. Family”). see contributor informed “id-60 IsSonOf id-47” ; hr_import() function automatically created opposite (“id_47 IsParentOf id-60”), using inverse terms retrievable z.h.vocabularies. Let’s look relationships regarding “id-47” person : obtain 3 relationships : matches content “relmarker” field dataframe Personne (column Carrière & Parentèle.relationship). Please note : previous example, ’ve used column z.h.id.Personne dataframe Personne, column Carrière & Parentèle.relationship dataframe Personne. Indeed, joined column, relation duplicated.  ","code":"`Record relationship` %>%   inner_join(z.h.vocabularies %>%                filter(Level1==\"4. Family\"),              by=c(\"Relationship type\"=\"trm_Label\")) %>%   select(`z.h.id.Record relationship`,`Source record`,`Target record`,`Relationship type`,z.h.original) %>%   kable() Personne %>%    filter(z.h.id.Personne==\"47\") %>%    inner_join(`Record relationship`,              by=c(\"z.h.id.Personne\"=\"Source record\")) %>%   select(z.h.id.Personne,Nom_1,Prénom,          `z.h.id.Record relationship`,`Relationship type`,          `Target record`,z.h.original) %>%   kable() Personne %>%    filter(z.h.id.Personne==\"47\") %>%   select(z.h.id.Personne,`Carrière & Parentèle.relationship`) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"dealing-with-place","dir":"","previous_headings":"","what":"Dealing with “Place”","title":"To make easier quantitative analysis from Heurist databases","text":"Since 2023, dataframe Place (corresponding eponymous ‘record type’) contained column named z.h.reversePointer. column reports ID related entities. instance, let’s see objects (dataframe Objet) found (field ‘Lieu de la trouvaille’ referring Place) : find values z.h.id.Objet field z.h.reversePointer dataframe Place : Normally, dataframe Place contains field type “geo” : deal field ? See , “Dealing temporal, spatial file fields”.  ","code":"Objet %>%    select(z.h.id.Objet,z.h.title.Objet,`Lieu de la trouvaille`) %>%   kable() Place %>%   select(z.h.id.Place,z.h.title.Place,z.h.reversePointer) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"dealing-with-temporal-spatial-and-file-fields","dir":"","previous_headings":"","what":"Dealing with temporal, spatial and file fields","title":"To make easier quantitative analysis from Heurist databases","text":"name “temporal, spatial file fields” values informed fields (“detail types” Heurist language) type “date”, “geo” “file”. fields match value “date”, “geo” “file” column field.type dataframe z.h.tables.fields. look informed fields (empty fields), select fields matching value “empty” column field.empty z.h.tables.fields.","code":"z.h.tables.fields %>%    filter(field.type %in% c(\"date\",\"geo\",\"file\") &             field.empty==\"no empty\") %>%   select(table.name,field.DisplayName,field.type) %>%   arrange(table.name,field.type) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"temporal-fields","dir":"","previous_headings":"Dealing with temporal, spatial and file fields","what":"Temporal fields","title":"To make easier quantitative analysis from Heurist databases","text":"different types “temporal” fields : C14 Date : Heurist contributor clicked symbol “clock”, Radiometric tab ; Date Range : Heurist contributor clicked symbol “clock”, Fuzzy Range tab ; Approximate Date : Heurist contributor clicked symbol “clock”, Simple Range tab ; indexed : Heurist contributor hasn’t clicked symbol “clock” “calendar”, value unlike “YYYY-MM-DD” (“YYYY-MM” “YYYY”) ; Simple Date Date : actually, since Heurist’s update 2023, ’ve understood difference beetween … Unlike Dates, Simple Dates defined <temporal> tag Heurist XML export. November 2023, actions certainly create <temporal> tags : click symbol “clock”  whe choose ‘Type Determination’ define ‘Simple Range’, ‘Fuzzy Range’ ‘Radiometric’. sometimes, value looks like “YYYY-MM-DD” “YYYY”, <temporal> tag appears whereas actions taken. However, writing value like “YYYY-MM-DD” “YYYY” systematically create <temporal> tag !  2023, “temporal field” without <temporal> tag meant contributor never clicked clock calendar symbols field, used inform “Manual Date” instead “Date”. “Temporal” fields declined several columns according “temporal.type” value original XML file. example, dataframe Personne, values Date de naissance recorded three ways : manually, without following “YYYY-MM-DD” format (= “indexed”) following “YYYY-MM-DD” (“YYYY” “YYYY-MM”) format (= “Simple Date” “Date”) Columns containing “.DAT.” informed “Simple Dates”, “Approximate Dates” “Dates” (N.B : columns ending “.DAT.raw” informed “Simple Dates” “Approximate Dates”). want transform “temporal” fields “date vectors”, careful : values can refer “numeric” date (example : “Printemps 1960”) - ’s ’s important distinguish “indexed” dates ; “Dates” formats can different : can refer specific day, others month, others year… following lines, choose consider first day first month, day month informed. dataframe Objet, values Date de création recorded three ways : “Approximate Date”, “C14 Date” “Date range” (see ). Therefore, Date de création declined several columns : TPQ (Terminus Post-Quem),PDB (Probable Date Begin),PDE (Probable Date End) TAQ (Terminus Ante-Quem) deal “Date Range” ; BCE (Current Era),BDP (Present),DEV (Std dev), DVP (Pos Dev) DVN (Neg Dev) deal “C14 Date” ; DAT (Date) RNG (Range) deal “Approximate Date”. Values “temporal” fields can described several columns specifying “year”, “month”, “day” (see Date de naissance), also “hours”, “minutes” “seconds”. example, End date dataframe Objet Exposition : N.B : Values “raw” dates modified 2023, result Heurist’s update. See examples changes : seems format “2023” remains dates , Heurist’update, become indexed. See example :","code":"# Count \"temporal.type\" Personne %>% count(`Date de naissance.temporal.type`) %>%    kable() # Colnames names(Personne)[grepl(\"^Date de naissance.+\",names(Personne))] #> [1] \"Date de naissance.temporal.raw\"  \"Date de naissance.temporal.type\" #> [3] \"Date de naissance.DAT.raw\"       \"Date de naissance.DAT.year\"      #> [5] \"Date de naissance.DAT.month\"     \"Date de naissance.DAT.day\"       #> [7] \"Date de naissance.property.COM\"  \"Date de naissance.property.DET\"  # Records Personne %>%    select(z.h.title.Personne,starts_with(\"Date de naissance\")) %>%   kable() Personne %>%    mutate_at(vars(`Date de naissance.DAT.month`,                  `Date de naissance.DAT.day`),             replace_na,\"01\") %>%   mutate(date_naiss = as.Date(str_c(`Date de naissance.DAT.year`,                                 `Date de naissance.DAT.month`,                                 `Date de naissance.DAT.day`,                                 sep=\"-\"))) %>%   select(z.h.title.Personne,date_naiss) %>%   arrange(date_naiss) %>%   kable() Objet %>% count(`Date de création.temporal.type`) %>% kable() # Colnames names(Objet)[grepl(\"^Date de création.+\",names(Objet))] #>  [1] \"Date de création.temporal.raw\"  \"Date de création.temporal.type\" #>  [3] \"Date de création.DAT.raw\"       \"Date de création.DAT.year\"      #>  [5] \"Date de création.TPQ.raw\"       \"Date de création.TPQ.year\"      #>  [7] \"Date de création.PDB.raw\"       \"Date de création.PDB.year\"      #>  [9] \"Date de création.PDE.raw\"       \"Date de création.PDE.year\"      #> [11] \"Date de création.TAQ.raw\"       \"Date de création.TAQ.year\"      #> [13] \"Date de création.BCE.raw\"       \"Date de création.BCE.year\"      #> [15] \"Date de création.BPD.raw\"       \"Date de création.BPD.year\"      #> [17] \"Date de création.DEV.raw\"       \"Date de création.DEV.year\"      #> [19] \"Date de création.DVP.raw\"       \"Date de création.DVP.year\"      #> [21] \"Date de création.DVN.raw\"       \"Date de création.DVN.year\"      #> [23] \"Date de création.RNG.raw\"       \"Date de création.RNG.year\"      #> [25] \"Date de création.property.COD\"  \"Date de création.property.DET\"  # Records Objet %>%    select(z.h.title.Objet,starts_with(\"Date de création\")) %>%   kable() # Colnames names(`Objet - Exposition`)[grepl(\"^End date.+\",names(`Objet - Exposition`))] #>  [1] \"End date.temporal.raw\"  \"End date.temporal.type\" \"End date.DAT.raw\"       #>  [4] \"End date.DAT.year\"      \"End date.DAT.month\"     \"End date.DAT.day\"       #>  [7] \"End date.DAT.hour\"      \"End date.DAT.minutes\"   \"End date.DAT.seconds\"   #> [10] \"End date.property.DET\"  \"End date.1\"             \"End date.2\"  # Records `Objet - Exposition` %>%    select(`z.h.id.Objet - Exposition`,starts_with(\"End date\")) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"spatial-fields","dir":"","previous_headings":"Dealing with temporal, spatial and file fields","what":"Spatial fields","title":"To make easier quantitative analysis from Heurist databases","text":"“Spatial” fields always declined 2 columns : one finishing “.geo.type” one finishing “.geo.wkt” Let’s look Location (mappable) dataframe Place : Using sf package, ’re abble cartography “spatial field” type “point” way :   ","code":"# Colnames names(Place)[grepl(\"^Location \\\\(mappable\\\\).+\",names(Place))] #> [1] \"Location (mappable).geo.type\" \"Location (mappable).geo.wkt\"  # Records Place %>%    select(z.h.title.Place,starts_with(\"Location (mappable)\")) %>%   kable() library(sf)  # Creating a sf object with sf::st_as_sf() sf_Place_point <- Place %>%   filter(`Location (mappable).geo.type`==\"point\") %>%   rename(\"geom\"=\"Location (mappable).geo.wkt\") %>%   st_as_sf(wkt = \"geom\",crs = st_crs(4326))  # Plotting with ggplot2 sf_Place_point %>%   ggplot() +   geom_sf(col=\"red\") +   geom_sf_label(aes(label=z.h.title.Place,hjust=0, vjust = 1),                 col=\"red\",size=2.7)"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"file-fields","dir":"","previous_headings":"Dealing with temporal, spatial and file fields","what":"File fields","title":"To make easier quantitative analysis from Heurist databases","text":"“File” fields may declined several columns describing file paradata. Let’s look Logo dataframe Laboratoire : click URL (column Logo.file.URL), file appears new window.  ","code":"# Colnames names(Laboratoire)[grepl(\"^Logo.+\",names(Laboratoire))] #> [1] \"Logo.file.date\"     \"Logo.file.fileSize\" \"Logo.file.id\"       #> [4] \"Logo.file.mimeType\" \"Logo.file.nonce\"    \"Logo.file.origName\" #> [7] \"Logo.file.url\"  # Records Laboratoire %>%    select(z.h.title.Laboratoire,starts_with(\"Logo\")) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"renaming-tables-and-columns---if-desired","dir":"","previous_headings":"","what":"Renaming tables and columns - if desired","title":"To make easier quantitative analysis from Heurist databases","text":"avoid using symbol ` R, remember can easily remove spaces, dashes, slashes, commas, quotations marks, ampersands parenthesis colnames dataframes names. Indeed, “TRUE”, argument rename.tab.col hr_import function replaces characters dots. Dataframes names : instance, colnames Objet rename.tab.col=F rename.tab.col=T : Please note : parameter rename.tab.col=TRUE creates two additional columns dataframe z.h.tables.fields : table.name.renamed field.renamed.","code":"hr_import(data.file=\"documents/data_example/aliet_test_R_data.xml\",           structure.file=\"documents/data_example/aliet_test_R_structure.xml\",           rename.tab.col=TRUE) #> We're importing data and structure files (most time-consuming step)... Thank you for waiting... #> Data and structure files have been successfully imported. Now we're selecting and managing data... Thank you for waiting... #> We've finished. It's ready to use ! #> Spaces, dashes, slashes, commas, quotations marks, ampersands and parenthesis have been removed from names, replaced with dots #> Import has required 8.53 secs ls()  #> [1] \"Laboratoire\"         \"Objet\"               \"Objet.Exposition\"    #> [4] \"Personne\"            \"Place\"               \"Record.relationship\" #> [7] \"z.h.tables.fields\"   \"z.h.vocabularies\" z.h.tables.fields %>% filter(table.name==\"Objet\") %>%   select(table.name,field.DisplayName,table.name.renamed,field.renamed) %>%   kable()"},{"path":"https://alietteroux.github.io/HeuristToR/index.html","id":"saving-data-into-a-r-data-file","dir":"","previous_headings":"","what":"Saving data into a R data file","title":"To make easier quantitative analysis from Heurist databases","text":"rh_import() taken long time, remember can save workspace file named .RData, quickly restore . give example following lines (’d like save objects enviroment folder named “export”) :","code":"# Saving all objects of the environment save.image(file = \"export/aliet_test_R.RData\") # Restoring all of these objects load(\"export/aliet_test_R.RData\")"},{"path":"https://alietteroux.github.io/HeuristToR/reference/HeuristToR-package.html","id":null,"dir":"Reference","previous_headings":"","what":"HeuristToR: To make easier quantitative analysis from Heurist databases — HeuristToR-package","title":"HeuristToR: To make easier quantitative analysis from Heurist databases — HeuristToR-package","text":"far, package contains one function : hr_import(). function reads XML files exported Heurist (https://heuristnetwork.org/) build many dataframes 'record types' used Heurist database. Heurist 'record type' matches dataframe ; Heurist 'record' matches row dataframe. Furthermore, function builds two dataframes describing fields (type, help text, requirement, repeatability...) vocabularies.","code":""},{"path":[]},{"path":"https://alietteroux.github.io/HeuristToR/reference/HeuristToR-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"HeuristToR: To make easier quantitative analysis from Heurist databases — HeuristToR-package","text":"Maintainer: Aliette Roux aliette.roux@univ-nantes.fr","code":""},{"path":"https://alietteroux.github.io/HeuristToR/reference/hr_import.html","id":null,"dir":"Reference","previous_headings":"","what":"Read data and paradata from Heurist database — hr_import","title":"Read data and paradata from Heurist database — hr_import","text":"function reads XML files exported Heurist build many dataframes 'record types' used Heurist database. Heurist 'record type' matches dataframe ; Heurist 'record' matches row dataframe. Furthermore, function builds two dataframes describing fields (type, help text, requirement, repeatability...) vocabularies.","code":""},{"path":"https://alietteroux.github.io/HeuristToR/reference/hr_import.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read data and paradata from Heurist database — hr_import","text":"","code":"hr_import(data.file, structure.file, rename.tab.col)"},{"path":"https://alietteroux.github.io/HeuristToR/reference/hr_import.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read data and paradata from Heurist database — hr_import","text":"data.file XML file exported Heurist including data (fields'values entered database) : XML file can exported Heurist via Explore menu > Export > XML. careful : records selected Heurist session export, data theses selected records exported. structure.file XML file exported Heurist describing database structure (vocabularies, fields'caracteristics...) : XML file can exported Heurist via Design menu > Download > Structure (XML). rename.tab.col Boolean. FALSE default. TRUE, spaces, dashes, slashes, commas, quotations marks, ampersands parenthesis removed colnames dataframes names, replaced dots.","code":""},{"path":"https://alietteroux.github.io/HeuristToR/reference/hr_import.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read data and paradata from Heurist database — hr_import","text":"Several dataframes Heurist 'record type' dataframe : dataframes, row matches Heurist 'record' dataframe named \"z.h.tables.fields\" : row describes field used Heurist 'record type' (type, help text, requirement, repeatability...) dataframe named \"z.h.vocabularies\" : row matches term used Heurist vocabulary ; term joined level (ranking position vocabulary) attached parents'terms","code":""},{"path":"https://alietteroux.github.io/HeuristToR/reference/hr_import.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read data and paradata from Heurist database — hr_import","text":"details : tutorial https://alietteroux.github.io/heuristtor/ Github repository https://github.com/alietteroux/heuristtor","code":""}]
